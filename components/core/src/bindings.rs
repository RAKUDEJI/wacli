// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
#[allow(dead_code, clippy::all)]
pub mod wacli {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ExitCode = u32;
      #[derive(Clone)]
      pub struct CommandMeta {
        pub name: _rt::String,
        pub summary: _rt::String,
        pub usage: _rt::String,
        pub aliases: _rt::Vec::<_rt::String>,
        pub version: _rt::String,
        pub hidden: bool,
        pub description: _rt::String,
        pub examples: _rt::Vec::<_rt::String>,
      }
      impl ::core::fmt::Debug for CommandMeta {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CommandMeta").field("name", &self.name).field("summary", &self.summary).field("usage", &self.usage).field("aliases", &self.aliases).field("version", &self.version).field("hidden", &self.hidden).field("description", &self.description).field("examples", &self.examples).finish()
        }
      }
      #[derive(Clone)]
      pub enum CommandError {
        UnknownCommand(_rt::String),
        InvalidArgs(_rt::String),
        Failed(_rt::String),
        Io(_rt::String),
      }
      impl ::core::fmt::Debug for CommandError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CommandError::UnknownCommand(e) => {
              f.debug_tuple("CommandError::UnknownCommand").field(e).finish()
            }
            CommandError::InvalidArgs(e) => {
              f.debug_tuple("CommandError::InvalidArgs").field(e).finish()
            }
            CommandError::Failed(e) => {
              f.debug_tuple("CommandError::Failed").field(e).finish()
            }
            CommandError::Io(e) => {
              f.debug_tuple("CommandError::Io").field(e).finish()
            }
          }
        }
      }
      pub type CommandResult= Result<ExitCode,CommandError>;

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod host {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ExitCode = super::super::super::wacli::cli::types::ExitCode;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn args() -> _rt::Vec::<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "args"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base7 = l2;
          let len7 = l3;
          let mut result7 = _rt::Vec::with_capacity(len7);
          for i in 0..len7 {
            let base = base7.add(i * (2*::core::mem::size_of::<*const u8>()));
            let e7 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

              _rt::string_lift(bytes6)
            };
            result7.push(e7);
          }
          _rt::cabi_dealloc(base7, len7 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result8 = result7;
          result8
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn env() -> _rt::Vec::<(_rt::String,_rt::String,)>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "env"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base10 = l2;
          let len10 = l3;
          let mut result10 = _rt::Vec::with_capacity(len10);
          for i in 0..len10 {
            let base = base10.add(i * (4*::core::mem::size_of::<*const u8>()));
            let e10 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

              (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
            };
            result10.push(e10);
          }
          _rt::cabi_dealloc(base10, len10 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result11 = result10;
          result11
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stdout_write(bytes: &[u8],) -> (){
        unsafe {
          let vec0 = bytes;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "stdout-write"]
            fn wit_import1(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) { unreachable!() }
          wit_import1(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stderr_write(bytes: &[u8],) -> (){
        unsafe {
          let vec0 = bytes;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "stderr-write"]
            fn wit_import1(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) { unreachable!() }
          wit_import1(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stdout_flush() -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "stdout-flush"]
            fn wit_import0();
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() { unreachable!() }
          wit_import0();
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stderr_flush() -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "stderr-flush"]
            fn wit_import0();
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() { unreachable!() }
          wit_import0();
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stdin_read(max_bytes: u32,) -> _rt::Vec::<u8>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "stdin-read"]
            fn wit_import1(_: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
          wit_import1(_rt::as_i32(&max_bytes), ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len4 = l3;
          let result5 = <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l2.cast(), len4, len4));
          result5
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn is_tty_stdout() -> bool{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "is-tty-stdout"]
            fn wit_import0() -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
          let ret = wit_import0();
          _rt::bool_lift(ret as u8)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn is_tty_stderr() -> bool{
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "is-tty-stderr"]
            fn wit_import0() -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
          let ret = wit_import0();
          _rt::bool_lift(ret as u8)
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn terminal_size() -> Option<(u32,u32,)>{
        unsafe {

          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "terminal-size"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result5 = match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = *ptr0.add(4).cast::<i32>();
                let l4 = *ptr0.add(8).cast::<i32>();

                (l3 as u32, l4 as u32)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result5
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn exit(code: ExitCode,) -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host@1.0.0")]
          unsafe extern "C" {
            #[link_name = "exit"]
            fn wit_import0(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
          wit_import0(_rt::as_i32(code));
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod registry {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type CommandMeta = super::super::super::wacli::cli::types::CommandMeta;
      pub type CommandResult = super::super::super::wacli::cli::types::CommandResult;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn list_commands() -> _rt::Vec::<CommandMeta>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/registry@1.0.0")]
          unsafe extern "C" {
            #[link_name = "list-commands"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base32 = l2;
          let len32 = l3;
          let mut result32 = _rt::Vec::with_capacity(len32);
          for i in 0..len32 {
            let base = base32.add(i * (15*::core::mem::size_of::<*const u8>()));
            let e32 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
              let l10 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l11 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len12 = l11;
              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
              let l13 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l14 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base18 = l13;
              let len18 = l14;
              let mut result18 = _rt::Vec::with_capacity(len18);
              for i in 0..len18 {
                let base = base18.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e18 = {
                  let l15 = *base.add(0).cast::<*mut u8>();
                  let l16 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len17 = l16;
                  let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                  _rt::string_lift(bytes17)
                };
                result18.push(e18);
              }
              _rt::cabi_dealloc(base18, len18 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              let l19 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l20 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len21 = l20;
              let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);
              let l22 = i32::from(*base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
              let l23 = *base.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l24 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len25 = l24;
              let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
              let l26 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l27 = *base.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base31 = l26;
              let len31 = l27;
              let mut result31 = _rt::Vec::with_capacity(len31);
              for i in 0..len31 {
                let base = base31.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e31 = {
                  let l28 = *base.add(0).cast::<*mut u8>();
                  let l29 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len30 = l29;
                  let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                  _rt::string_lift(bytes30)
                };
                result31.push(e31);
              }
              _rt::cabi_dealloc(base31, len31 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

              super::super::super::wacli::cli::types::CommandMeta{
                name: _rt::string_lift(bytes6),
                summary: _rt::string_lift(bytes9),
                usage: _rt::string_lift(bytes12),
                aliases: result18,
                version: _rt::string_lift(bytes21),
                hidden: _rt::bool_lift(l22 as u8),
                description: _rt::string_lift(bytes25),
                examples: result31,
              }
            };
            result32.push(e32);
          }
          _rt::cabi_dealloc(base32, len32 * (15*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result33 = result32;
          result33
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn run(name: &str,argv: &[_rt::String],) -> CommandResult{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec2 = argv;
          let len2 = vec2.len();
          let layout2 = _rt::alloc::Layout::from_size_align(vec2.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
          let (result2, _cleanup2) = wit_bindgen::rt::Cleanup::new(layout2);for (i, e) in vec2.into_iter().enumerate() {
            let base = result2.add(i * (2*::core::mem::size_of::<*const u8>()));
            {
              let vec1 = e;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
              *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
            }
          }
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/registry@1.0.0")]
          unsafe extern "C" {
            #[link_name = "run"]
            fn wit_import4(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import4(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import4(ptr0.cast_mut(), len0, result2, len2, ptr3);
          let l5 = i32::from(*ptr3.add(0).cast::<u8>());
          let result21 = match l5 {
            0 => {
              let e = {
                let l6 = *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<i32>();

                l6 as u32
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                use super::super::super::wacli::cli::types::CommandError as V20;
                let v20 = match l7 {
                  0 => {
                    let e20 = {
                      let l8 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l9 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len10 = l9;
                      let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                      _rt::string_lift(bytes10)
                    };
                    V20::UnknownCommand(e20)
                  }
                  1 => {
                    let e20 = {
                      let l11 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l12 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len13 = l12;
                      let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                      _rt::string_lift(bytes13)
                    };
                    V20::InvalidArgs(e20)
                  }
                  2 => {
                    let e20 = {
                      let l14 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l15 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len16 = l15;
                      let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                      _rt::string_lift(bytes16)
                    };
                    V20::Failed(e20)
                  }
                  n => {
                    debug_assert_eq!(n, 3, "invalid enum discriminant");
                    let e20 = {
                      let l17 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l18 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len19 = l18;
                      let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                      _rt::string_lift(bytes19)
                    };
                    V20::Io(e20)
                  }
                };

                v20
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result21
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod wasi {
    pub mod cli {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod run {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        #[doc(hidden)]
        #[allow(non_snake_case, unused_unsafe)]
        pub unsafe fn _export_run_cabi<T: Guest>() -> i32 { unsafe {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let result0 = {
          T::run()
        };
        let result1 = match result0 {
          Ok(_) => { 0i32 },
          Err(_) => { 1i32 },
        };result1
      } }
      pub trait Guest {
        /// Run the program.
        #[allow(async_fn_in_trait)]
        fn run() -> Result<(),()>;
      }
      #[doc(hidden)]

      macro_rules! __export_wasi_cli_run_0_2_9_cabi{
        ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          #[unsafe(export_name = "wasi:cli/run@0.2.9#run")]
          unsafe extern "C" fn export_run() -> i32 {
            unsafe { $($path_to_types)*::_export_run_cabi::<$ty>() }
          }
        };);
      }
      #[doc(hidden)]
      pub(crate) use __export_wasi_cli_run_0_2_9_cabi;

    }

  }
}
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]
  pub use alloc_crate::string::String;
  pub use alloc_crate::vec::Vec;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  pub use alloc_crate::alloc;

  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_core_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::wasi::cli::run::__export_wasi_cli_run_0_2_9_cabi!($ty with_types_in $($path_to_types_root)*::exports::wasi::cli::run);
  )
}
#[doc(inline)]
pub(crate) use __export_core_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:wacli:cli@1.0.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 918] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x9b\x06\x01A\x02\x01\
A\x0b\x01B\x09\x01y\x04\0\x09exit-code\x03\0\0\x01ps\x01r\x08\x04names\x07summar\
ys\x05usages\x07aliases\x02\x07versions\x06hidden\x7f\x0bdescriptions\x08example\
s\x02\x04\0\x0ccommand-meta\x03\0\x03\x01q\x04\x0funknown-command\x01s\0\x0cinva\
lid-args\x01s\0\x06failed\x01s\0\x02io\x01s\0\x04\0\x0dcommand-error\x03\0\x05\x01\
j\x01\x01\x01\x06\x04\0\x0ecommand-result\x03\0\x07\x03\0\x15wacli:cli/types@1.0\
.0\x05\0\x02\x03\0\0\x09exit-code\x01B\x1b\x02\x03\x02\x01\x01\x04\0\x09exit-cod\
e\x03\0\0\x01ps\x01@\0\0\x02\x04\0\x04args\x01\x03\x01o\x02ss\x01p\x04\x01@\0\0\x05\
\x04\0\x03env\x01\x06\x01p}\x01@\x01\x05bytes\x07\x01\0\x04\0\x0cstdout-write\x01\
\x08\x04\0\x0cstderr-write\x01\x08\x01@\0\x01\0\x04\0\x0cstdout-flush\x01\x09\x04\
\0\x0cstderr-flush\x01\x09\x01@\x01\x09max-bytesy\0\x07\x04\0\x0astdin-read\x01\x0a\
\x01@\0\0\x7f\x04\0\x0dis-tty-stdout\x01\x0b\x04\0\x0dis-tty-stderr\x01\x0b\x01o\
\x02yy\x01k\x0c\x01@\0\0\x0d\x04\0\x0dterminal-size\x01\x0e\x01@\x01\x04code\x01\
\x01\0\x04\0\x04exit\x01\x0f\x03\0\x14wacli:cli/host@1.0.0\x05\x02\x02\x03\0\0\x0c\
command-meta\x02\x03\0\0\x0ecommand-result\x01B\x0a\x02\x03\x02\x01\x03\x04\0\x0c\
command-meta\x03\0\0\x02\x03\x02\x01\x04\x04\0\x0ecommand-result\x03\0\x02\x01p\x01\
\x01@\0\0\x04\x04\0\x0dlist-commands\x01\x05\x01ps\x01@\x02\x04names\x04argv\x06\
\0\x03\x04\0\x03run\x01\x07\x03\0\x18wacli:cli/registry@1.0.0\x05\x05\x01B\x03\x01\
j\0\0\x01@\0\0\0\x04\0\x03run\x01\x01\x04\0\x12wasi:cli/run@0.2.9\x05\x06\x04\0\x14\
wacli:cli/core@1.0.0\x04\0\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.244.0\x10wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

