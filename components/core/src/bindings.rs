// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
#[allow(dead_code, clippy::all)]
pub mod wacli {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod host_env {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn args() -> _rt::Vec::<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-env@2.0.0")]
          unsafe extern "C" {
            #[link_name = "args"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base7 = l2;
          let len7 = l3;
          let mut result7 = _rt::Vec::with_capacity(len7);
          for i in 0..len7 {
            let base = base7.add(i * (2*::core::mem::size_of::<*const u8>()));
            let e7 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

              _rt::string_lift(bytes6)
            };
            result7.push(e7);
          }
          _rt::cabi_dealloc(base7, len7 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result8 = result7;
          result8
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn env() -> _rt::Vec::<(_rt::String,_rt::String,)>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-env@2.0.0")]
          unsafe extern "C" {
            #[link_name = "env"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base10 = l2;
          let len10 = l3;
          let mut result10 = _rt::Vec::with_capacity(len10);
          for i in 0..len10 {
            let base = base10.add(i * (4*::core::mem::size_of::<*const u8>()));
            let e10 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

              (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
            };
            result10.push(e10);
          }
          _rt::cabi_dealloc(base10, len10 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result11 = result10;
          result11
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod host_io {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stdout_write(bytes: &[u8],) -> (){
        unsafe {
          let vec0 = bytes;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-io@2.0.0")]
          unsafe extern "C" {
            #[link_name = "stdout-write"]
            fn wit_import1(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) { unreachable!() }
          wit_import1(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stderr_write(bytes: &[u8],) -> (){
        unsafe {
          let vec0 = bytes;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-io@2.0.0")]
          unsafe extern "C" {
            #[link_name = "stderr-write"]
            fn wit_import1(_: *mut u8, _: usize, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, ) { unreachable!() }
          wit_import1(ptr0.cast_mut(), len0);
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stdout_flush() -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-io@2.0.0")]
          unsafe extern "C" {
            #[link_name = "stdout-flush"]
            fn wit_import0();
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() { unreachable!() }
          wit_import0();
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn stderr_flush() -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-io@2.0.0")]
          unsafe extern "C" {
            #[link_name = "stderr-flush"]
            fn wit_import0();
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0() { unreachable!() }
          wit_import0();
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ExitCode = u32;
      #[derive(Clone)]
      pub struct ArgDef {
        pub name: _rt::String,
        pub short: Option<_rt::String>,
        pub long: Option<_rt::String>,
        pub help: _rt::String,
        pub required: bool,
        pub default_value: Option<_rt::String>,
        pub value_name: Option<_rt::String>,
        pub takes_value: bool,
      }
      impl ::core::fmt::Debug for ArgDef {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ArgDef").field("name", &self.name).field("short", &self.short).field("long", &self.long).field("help", &self.help).field("required", &self.required).field("default-value", &self.default_value).field("value-name", &self.value_name).field("takes-value", &self.takes_value).finish()
        }
      }
      #[derive(Clone)]
      pub struct CommandMeta {
        pub name: _rt::String,
        pub summary: _rt::String,
        pub usage: _rt::String,
        pub aliases: _rt::Vec::<_rt::String>,
        pub version: _rt::String,
        pub hidden: bool,
        pub description: _rt::String,
        pub examples: _rt::Vec::<_rt::String>,
        pub args: _rt::Vec::<ArgDef>,
      }
      impl ::core::fmt::Debug for CommandMeta {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CommandMeta").field("name", &self.name).field("summary", &self.summary).field("usage", &self.usage).field("aliases", &self.aliases).field("version", &self.version).field("hidden", &self.hidden).field("description", &self.description).field("examples", &self.examples).field("args", &self.args).finish()
        }
      }
      #[derive(Clone)]
      pub enum CommandError {
        UnknownCommand(_rt::String),
        InvalidArgs(_rt::String),
        Failed(_rt::String),
        Io(_rt::String),
      }
      impl ::core::fmt::Debug for CommandError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CommandError::UnknownCommand(e) => {
              f.debug_tuple("CommandError::UnknownCommand").field(e).finish()
            }
            CommandError::InvalidArgs(e) => {
              f.debug_tuple("CommandError::InvalidArgs").field(e).finish()
            }
            CommandError::Failed(e) => {
              f.debug_tuple("CommandError::Failed").field(e).finish()
            }
            CommandError::Io(e) => {
              f.debug_tuple("CommandError::Io").field(e).finish()
            }
          }
        }
      }
      pub type CommandResult= Result<ExitCode,CommandError>;
      #[derive(Clone)]
      pub struct PipeMeta {
        pub name: _rt::String,
        pub summary: _rt::String,
        pub input_types: _rt::Vec::<_rt::String>,
        pub output_type: _rt::String,
        pub version: _rt::String,
      }
      impl ::core::fmt::Debug for PipeMeta {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PipeMeta").field("name", &self.name).field("summary", &self.summary).field("input-types", &self.input_types).field("output-type", &self.output_type).field("version", &self.version).finish()
        }
      }
      #[derive(Clone)]
      pub enum PipeError {
        ParseError(_rt::String),
        TransformError(_rt::String),
        InvalidOption(_rt::String),
      }
      impl ::core::fmt::Debug for PipeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PipeError::ParseError(e) => {
              f.debug_tuple("PipeError::ParseError").field(e).finish()
            }
            PipeError::TransformError(e) => {
              f.debug_tuple("PipeError::TransformError").field(e).finish()
            }
            PipeError::InvalidOption(e) => {
              f.debug_tuple("PipeError::InvalidOption").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for PipeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }

      impl ::core::error::Error for PipeError {}
      #[derive(Clone)]
      pub struct PipeInfo {
        pub name: _rt::String,
        pub summary: _rt::String,
        pub path: _rt::String,
      }
      impl ::core::fmt::Debug for PipeInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PipeInfo").field("name", &self.name).field("summary", &self.summary).field("path", &self.path).finish()
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod host_process {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ExitCode = super::super::super::wacli::cli::types::ExitCode;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn exit(code: ExitCode,) -> (){
        unsafe {

          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/host-process@2.0.0")]
          unsafe extern "C" {
            #[link_name = "exit"]
            fn wit_import0(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
          wit_import0(_rt::as_i32(code));
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod registry {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type CommandMeta = super::super::super::wacli::cli::types::CommandMeta;
      pub type CommandResult = super::super::super::wacli::cli::types::CommandResult;
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn list_commands() -> _rt::Vec::<CommandMeta>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/registry@2.0.0")]
          unsafe extern "C" {
            #[link_name = "list-commands"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base59 = l2;
          let len59 = l3;
          let mut result59 = _rt::Vec::with_capacity(len59);
          for i in 0..len59 {
            let base = base59.add(i * (17*::core::mem::size_of::<*const u8>()));
            let e59 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
              let l10 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l11 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len12 = l11;
              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
              let l13 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l14 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base18 = l13;
              let len18 = l14;
              let mut result18 = _rt::Vec::with_capacity(len18);
              for i in 0..len18 {
                let base = base18.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e18 = {
                  let l15 = *base.add(0).cast::<*mut u8>();
                  let l16 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len17 = l16;
                  let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                  _rt::string_lift(bytes17)
                };
                result18.push(e18);
              }
              _rt::cabi_dealloc(base18, len18 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              let l19 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l20 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len21 = l20;
              let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);
              let l22 = i32::from(*base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
              let l23 = *base.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l24 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len25 = l24;
              let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
              let l26 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l27 = *base.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base31 = l26;
              let len31 = l27;
              let mut result31 = _rt::Vec::with_capacity(len31);
              for i in 0..len31 {
                let base = base31.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e31 = {
                  let l28 = *base.add(0).cast::<*mut u8>();
                  let l29 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len30 = l29;
                  let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                  _rt::string_lift(bytes30)
                };
                result31.push(e31);
              }
              _rt::cabi_dealloc(base31, len31 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              let l32 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l33 = *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base58 = l32;
              let len58 = l33;
              let mut result58 = _rt::Vec::with_capacity(len58);
              for i in 0..len58 {
                let base = base58.add(i * (18*::core::mem::size_of::<*const u8>()));
                let e58 = {
                  let l34 = *base.add(0).cast::<*mut u8>();
                  let l35 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len36 = l35;
                  let bytes36 = _rt::Vec::from_raw_parts(l34.cast(), len36, len36);
                  let l37 = i32::from(*base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l41 = i32::from(*base.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l45 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l46 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len47 = l46;
                  let bytes47 = _rt::Vec::from_raw_parts(l45.cast(), len47, len47);
                  let l48 = i32::from(*base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l49 = i32::from(*base.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l53 = i32::from(*base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l57 = i32::from(*base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>());

                  super::super::super::wacli::cli::types::ArgDef{
                    name: _rt::string_lift(bytes36),
                    short: match l37 {
                      0 => None,
                      1 => {
                        let e = {
                          let l38 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l39 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len40 = l39;
                          let bytes40 = _rt::Vec::from_raw_parts(l38.cast(), len40, len40);

                          _rt::string_lift(bytes40)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    long: match l41 {
                      0 => None,
                      1 => {
                        let e = {
                          let l42 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l43 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len44 = l43;
                          let bytes44 = _rt::Vec::from_raw_parts(l42.cast(), len44, len44);

                          _rt::string_lift(bytes44)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    help: _rt::string_lift(bytes47),
                    required: _rt::bool_lift(l48 as u8),
                    default_value: match l49 {
                      0 => None,
                      1 => {
                        let e = {
                          let l50 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l51 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len52 = l51;
                          let bytes52 = _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                          _rt::string_lift(bytes52)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    value_name: match l53 {
                      0 => None,
                      1 => {
                        let e = {
                          let l54 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l55 = *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len56 = l55;
                          let bytes56 = _rt::Vec::from_raw_parts(l54.cast(), len56, len56);

                          _rt::string_lift(bytes56)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    takes_value: _rt::bool_lift(l57 as u8),
                  }
                };
                result58.push(e58);
              }
              _rt::cabi_dealloc(base58, len58 * (18*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

              super::super::super::wacli::cli::types::CommandMeta{
                name: _rt::string_lift(bytes6),
                summary: _rt::string_lift(bytes9),
                usage: _rt::string_lift(bytes12),
                aliases: result18,
                version: _rt::string_lift(bytes21),
                hidden: _rt::bool_lift(l22 as u8),
                description: _rt::string_lift(bytes25),
                examples: result31,
                args: result58,
              }
            };
            result59.push(e59);
          }
          _rt::cabi_dealloc(base59, len59 * (17*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result60 = result59;
          result60
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      #[allow(async_fn_in_trait)]
      pub fn run(name: &str,argv: &[_rt::String],) -> CommandResult{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec2 = argv;
          let len2 = vec2.len();
          let layout2 = _rt::alloc::Layout::from_size_align(vec2.len() * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
          let (result2, _cleanup2) = wit_bindgen::rt::Cleanup::new(layout2);for (i, e) in vec2.into_iter().enumerate() {
            let base = result2.add(i * (2*::core::mem::size_of::<*const u8>()));
            {
              let vec1 = e;
              let ptr1 = vec1.as_ptr().cast::<u8>();
              let len1 = vec1.len();
              *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len1;
              *base.add(0).cast::<*mut u8>() = ptr1.cast_mut();
            }
          }
          let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/registry@2.0.0")]
          unsafe extern "C" {
            #[link_name = "run"]
            fn wit_import4(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import4(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import4(ptr0.cast_mut(), len0, result2, len2, ptr3);
          let l5 = i32::from(*ptr3.add(0).cast::<u8>());
          let result21 = match l5 {
            0 => {
              let e = {
                let l6 = *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<i32>();

                l6 as u32
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l7 = i32::from(*ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                use super::super::super::wacli::cli::types::CommandError as V20;
                let v20 = match l7 {
                  0 => {
                    let e20 = {
                      let l8 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l9 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len10 = l9;
                      let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                      _rt::string_lift(bytes10)
                    };
                    V20::UnknownCommand(e20)
                  }
                  1 => {
                    let e20 = {
                      let l11 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l12 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len13 = l12;
                      let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);

                      _rt::string_lift(bytes13)
                    };
                    V20::InvalidArgs(e20)
                  }
                  2 => {
                    let e20 = {
                      let l14 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l15 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len16 = l15;
                      let bytes16 = _rt::Vec::from_raw_parts(l14.cast(), len16, len16);

                      _rt::string_lift(bytes16)
                    };
                    V20::Failed(e20)
                  }
                  n => {
                    debug_assert_eq!(n, 3, "invalid enum discriminant");
                    let e20 = {
                      let l17 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                      let l18 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len19 = l18;
                      let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                      _rt::string_lift(bytes19)
                    };
                    V20::Io(e20)
                  }
                };

                v20
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result21
        }
      }

    }

    /// Expressive CLI schema for clap-like behavior.
    ///
    /// This is intentionally more semantic than `types.arg-def`, allowing core-side
    /// help/version/validation without executing the plugin.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod schema {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[derive(Clone)]
      pub struct ArgSchema {
        pub name: _rt::String,
        pub short: Option<_rt::String>,
        pub long: Option<_rt::String>,
        pub help: _rt::String,
        pub required: bool,
        pub default_value: Option<_rt::String>,
        pub env: Option<_rt::String>,
        pub value_name: Option<_rt::String>,
        pub takes_value: bool,
        pub multiple: bool,
        pub value_type: Option<_rt::String>,
        pub possible_values: _rt::Vec::<_rt::String>,
        pub conflicts_with: _rt::Vec::<_rt::String>,
        pub requires: _rt::Vec::<_rt::String>,
        pub hidden: bool,
      }
      impl ::core::fmt::Debug for ArgSchema {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ArgSchema").field("name", &self.name).field("short", &self.short).field("long", &self.long).field("help", &self.help).field("required", &self.required).field("default-value", &self.default_value).field("env", &self.env).field("value-name", &self.value_name).field("takes-value", &self.takes_value).field("multiple", &self.multiple).field("value-type", &self.value_type).field("possible-values", &self.possible_values).field("conflicts-with", &self.conflicts_with).field("requires", &self.requires).field("hidden", &self.hidden).finish()
        }
      }
      #[derive(Clone)]
      pub struct CommandSchema {
        pub name: _rt::String,
        pub summary: _rt::String,
        pub usage: _rt::String,
        pub aliases: _rt::Vec::<_rt::String>,
        pub version: _rt::String,
        pub hidden: bool,
        pub description: _rt::String,
        pub examples: _rt::Vec::<_rt::String>,
        pub args: _rt::Vec::<ArgSchema>,
      }
      impl ::core::fmt::Debug for CommandSchema {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CommandSchema").field("name", &self.name).field("summary", &self.summary).field("usage", &self.usage).field("aliases", &self.aliases).field("version", &self.version).field("hidden", &self.hidden).field("description", &self.description).field("examples", &self.examples).field("args", &self.args).finish()
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod registry_schema {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type CommandSchema = super::super::super::wacli::cli::schema::CommandSchema;
      /// App-level metadata, provided by the builder (wacli).
      ///
      /// This is used by core to render global `--help/--version` consistently.
      #[derive(Clone)]
      pub struct AppMeta {
        pub name: _rt::String,
        pub version: _rt::String,
        pub description: _rt::String,
      }
      impl ::core::fmt::Debug for AppMeta {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("AppMeta").field("name", &self.name).field("version", &self.version).field("description", &self.description).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return app-level metadata for the composed CLI.
      #[allow(async_fn_in_trait)]
      pub fn get_app_meta() -> AppMeta{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 6*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 6*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/registry-schema@2.0.0")]
          unsafe extern "C" {
            #[link_name = "get-app-meta"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len4 = l3;
          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
          let l5 = *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l6 = *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len7 = l6;
          let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
          let l8 = *ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l9 = *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len10 = l9;
          let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);
          let result11 = AppMeta{
            name: _rt::string_lift(bytes4),
            version: _rt::string_lift(bytes7),
            description: _rt::string_lift(bytes10),
          };
          result11
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return schemas for all commands.
      ///
      /// The schema is pure data and must be available without executing the plugin.
      #[allow(async_fn_in_trait)]
      pub fn list_schemas() -> _rt::Vec::<CommandSchema>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wacli:cli/registry-schema@2.0.0")]
          unsafe extern "C" {
            #[link_name = "list-schemas"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base87 = l2;
          let len87 = l3;
          let mut result87 = _rt::Vec::with_capacity(len87);
          for i in 0..len87 {
            let base = base87.add(i * (17*::core::mem::size_of::<*const u8>()));
            let e87 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
              let l10 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l11 = *base.add(5*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len12 = l11;
              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
              let l13 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l14 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base18 = l13;
              let len18 = l14;
              let mut result18 = _rt::Vec::with_capacity(len18);
              for i in 0..len18 {
                let base = base18.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e18 = {
                  let l15 = *base.add(0).cast::<*mut u8>();
                  let l16 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len17 = l16;
                  let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                  _rt::string_lift(bytes17)
                };
                result18.push(e18);
              }
              _rt::cabi_dealloc(base18, len18 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              let l19 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l20 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len21 = l20;
              let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);
              let l22 = i32::from(*base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
              let l23 = *base.add(11*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l24 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len25 = l24;
              let bytes25 = _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
              let l26 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l27 = *base.add(14*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base31 = l26;
              let len31 = l27;
              let mut result31 = _rt::Vec::with_capacity(len31);
              for i in 0..len31 {
                let base = base31.add(i * (2*::core::mem::size_of::<*const u8>()));
                let e31 = {
                  let l28 = *base.add(0).cast::<*mut u8>();
                  let l29 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len30 = l29;
                  let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                  _rt::string_lift(bytes30)
                };
                result31.push(e31);
              }
              _rt::cabi_dealloc(base31, len31 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
              let l32 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l33 = *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let base86 = l32;
              let len86 = l33;
              let mut result86 = _rt::Vec::with_capacity(len86);
              for i in 0..len86 {
                let base = base86.add(i * (31*::core::mem::size_of::<*const u8>()));
                let e86 = {
                  let l34 = *base.add(0).cast::<*mut u8>();
                  let l35 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len36 = l35;
                  let bytes36 = _rt::Vec::from_raw_parts(l34.cast(), len36, len36);
                  let l37 = i32::from(*base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l41 = i32::from(*base.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l45 = *base.add(8*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l46 = *base.add(9*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len47 = l46;
                  let bytes47 = _rt::Vec::from_raw_parts(l45.cast(), len47, len47);
                  let l48 = i32::from(*base.add(10*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l49 = i32::from(*base.add(11*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l53 = i32::from(*base.add(14*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l57 = i32::from(*base.add(17*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l61 = i32::from(*base.add(20*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l62 = i32::from(*base.add(1+20*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l63 = i32::from(*base.add(21*::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let l67 = *base.add(24*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l68 = *base.add(25*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base72 = l67;
                  let len72 = l68;
                  let mut result72 = _rt::Vec::with_capacity(len72);
                  for i in 0..len72 {
                    let base = base72.add(i * (2*::core::mem::size_of::<*const u8>()));
                    let e72 = {
                      let l69 = *base.add(0).cast::<*mut u8>();
                      let l70 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len71 = l70;
                      let bytes71 = _rt::Vec::from_raw_parts(l69.cast(), len71, len71);

                      _rt::string_lift(bytes71)
                    };
                    result72.push(e72);
                  }
                  _rt::cabi_dealloc(base72, len72 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  let l73 = *base.add(26*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l74 = *base.add(27*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base78 = l73;
                  let len78 = l74;
                  let mut result78 = _rt::Vec::with_capacity(len78);
                  for i in 0..len78 {
                    let base = base78.add(i * (2*::core::mem::size_of::<*const u8>()));
                    let e78 = {
                      let l75 = *base.add(0).cast::<*mut u8>();
                      let l76 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len77 = l76;
                      let bytes77 = _rt::Vec::from_raw_parts(l75.cast(), len77, len77);

                      _rt::string_lift(bytes77)
                    };
                    result78.push(e78);
                  }
                  _rt::cabi_dealloc(base78, len78 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  let l79 = *base.add(28*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l80 = *base.add(29*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let base84 = l79;
                  let len84 = l80;
                  let mut result84 = _rt::Vec::with_capacity(len84);
                  for i in 0..len84 {
                    let base = base84.add(i * (2*::core::mem::size_of::<*const u8>()));
                    let e84 = {
                      let l81 = *base.add(0).cast::<*mut u8>();
                      let l82 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                      let len83 = l82;
                      let bytes83 = _rt::Vec::from_raw_parts(l81.cast(), len83, len83);

                      _rt::string_lift(bytes83)
                    };
                    result84.push(e84);
                  }
                  _rt::cabi_dealloc(base84, len84 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                  let l85 = i32::from(*base.add(30*::core::mem::size_of::<*const u8>()).cast::<u8>());

                  super::super::super::wacli::cli::schema::ArgSchema{
                    name: _rt::string_lift(bytes36),
                    short: match l37 {
                      0 => None,
                      1 => {
                        let e = {
                          let l38 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l39 = *base.add(4*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len40 = l39;
                          let bytes40 = _rt::Vec::from_raw_parts(l38.cast(), len40, len40);

                          _rt::string_lift(bytes40)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    long: match l41 {
                      0 => None,
                      1 => {
                        let e = {
                          let l42 = *base.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l43 = *base.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len44 = l43;
                          let bytes44 = _rt::Vec::from_raw_parts(l42.cast(), len44, len44);

                          _rt::string_lift(bytes44)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    help: _rt::string_lift(bytes47),
                    required: _rt::bool_lift(l48 as u8),
                    default_value: match l49 {
                      0 => None,
                      1 => {
                        let e = {
                          let l50 = *base.add(12*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l51 = *base.add(13*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len52 = l51;
                          let bytes52 = _rt::Vec::from_raw_parts(l50.cast(), len52, len52);

                          _rt::string_lift(bytes52)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    env: match l53 {
                      0 => None,
                      1 => {
                        let e = {
                          let l54 = *base.add(15*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l55 = *base.add(16*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len56 = l55;
                          let bytes56 = _rt::Vec::from_raw_parts(l54.cast(), len56, len56);

                          _rt::string_lift(bytes56)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    value_name: match l57 {
                      0 => None,
                      1 => {
                        let e = {
                          let l58 = *base.add(18*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l59 = *base.add(19*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len60 = l59;
                          let bytes60 = _rt::Vec::from_raw_parts(l58.cast(), len60, len60);

                          _rt::string_lift(bytes60)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    takes_value: _rt::bool_lift(l61 as u8),
                    multiple: _rt::bool_lift(l62 as u8),
                    value_type: match l63 {
                      0 => None,
                      1 => {
                        let e = {
                          let l64 = *base.add(22*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                          let l65 = *base.add(23*::core::mem::size_of::<*const u8>()).cast::<usize>();
                          let len66 = l65;
                          let bytes66 = _rt::Vec::from_raw_parts(l64.cast(), len66, len66);

                          _rt::string_lift(bytes66)
                        };
                        Some(e)
                      }
                      _ => _rt::invalid_enum_discriminant(),
                    },
                    possible_values: result72,
                    conflicts_with: result78,
                    requires: result84,
                    hidden: _rt::bool_lift(l85 as u8),
                  }
                };
                result86.push(e86);
              }
              _rt::cabi_dealloc(base86, len86 * (31*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());

              super::super::super::wacli::cli::schema::CommandSchema{
                name: _rt::string_lift(bytes6),
                summary: _rt::string_lift(bytes9),
                usage: _rt::string_lift(bytes12),
                aliases: result18,
                version: _rt::string_lift(bytes21),
                hidden: _rt::bool_lift(l22 as u8),
                description: _rt::string_lift(bytes25),
                examples: result31,
                args: result86,
              }
            };
            result87.push(e87);
          }
          _rt::cabi_dealloc(base87, len87 * (17*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result88 = result87;
          result88
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod wasi {
    pub mod cli {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod run {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        #[doc(hidden)]
        #[allow(non_snake_case, unused_unsafe)]
        pub unsafe fn _export_run_cabi<T: Guest>() -> i32 { unsafe {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();let result0 = {
          T::run()
        };
        let result1 = match result0 {
          Ok(_) => { 0i32 },
          Err(_) => { 1i32 },
        };result1
      } }
      pub trait Guest {
        /// Run the program.
        #[allow(async_fn_in_trait)]
        fn run() -> Result<(),()>;
      }
      #[doc(hidden)]

      macro_rules! __export_wasi_cli_run_0_2_9_cabi{
        ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          #[unsafe(export_name = "wasi:cli/run@0.2.9#run")]
          unsafe extern "C" fn export_run() -> i32 {
            unsafe { $($path_to_types)*::_export_run_cabi::<$ty>() }
          }
        };);
      }
      #[doc(hidden)]
      pub(crate) use __export_wasi_cli_run_0_2_9_cabi;

    }

  }
}
}
mod _rt {
  #![allow(dead_code, unused_imports, clippy::all)]
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::string::String;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  pub use alloc_crate::alloc;

  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_core_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::wasi::cli::run::__export_wasi_cli_run_0_2_9_cabi!($ty with_types_in $($path_to_types_root)*::exports::wasi::cli::run);
  )
}
#[doc(inline)]
pub(crate) use __export_core_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.52.0:wacli:cli@2.0.0:core:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1653] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xfa\x0b\x01A\x02\x01\
A\x14\x01B\x07\x01ps\x01@\0\0\0\x04\0\x04args\x01\x01\x01o\x02ss\x01p\x02\x01@\0\
\0\x03\x04\0\x03env\x01\x04\x03\0\x18wacli:cli/host-env@2.0.0\x05\0\x01B\x07\x01\
p}\x01@\x01\x05bytes\0\x01\0\x04\0\x0cstdout-write\x01\x01\x04\0\x0cstderr-write\
\x01\x01\x01@\0\x01\0\x04\0\x0cstdout-flush\x01\x02\x04\0\x0cstderr-flush\x01\x02\
\x03\0\x17wacli:cli/host-io@2.0.0\x05\x01\x01B\x13\x01y\x04\0\x09exit-code\x03\0\
\0\x01ks\x01r\x08\x04names\x05short\x02\x04long\x02\x04helps\x08required\x7f\x0d\
default-value\x02\x0avalue-name\x02\x0btakes-value\x7f\x04\0\x07arg-def\x03\0\x03\
\x01ps\x01p\x04\x01r\x09\x04names\x07summarys\x05usages\x07aliases\x05\x07versio\
ns\x06hidden\x7f\x0bdescriptions\x08examples\x05\x04args\x06\x04\0\x0ccommand-me\
ta\x03\0\x07\x01q\x04\x0funknown-command\x01s\0\x0cinvalid-args\x01s\0\x06failed\
\x01s\0\x02io\x01s\0\x04\0\x0dcommand-error\x03\0\x09\x01j\x01\x01\x01\x0a\x04\0\
\x0ecommand-result\x03\0\x0b\x01r\x05\x04names\x07summarys\x0binput-types\x05\x0b\
output-types\x07versions\x04\0\x09pipe-meta\x03\0\x0d\x01q\x03\x0bparse-error\x01\
s\0\x0ftransform-error\x01s\0\x0einvalid-option\x01s\0\x04\0\x0apipe-error\x03\0\
\x0f\x01r\x03\x04names\x07summarys\x04paths\x04\0\x09pipe-info\x03\0\x11\x03\0\x15\
wacli:cli/types@2.0.0\x05\x02\x02\x03\0\x02\x09exit-code\x01B\x04\x02\x03\x02\x01\
\x03\x04\0\x09exit-code\x03\0\0\x01@\x01\x04code\x01\x01\0\x04\0\x04exit\x01\x02\
\x03\0\x1cwacli:cli/host-process@2.0.0\x05\x04\x02\x03\0\x02\x0ccommand-meta\x02\
\x03\0\x02\x0ecommand-result\x01B\x0a\x02\x03\x02\x01\x05\x04\0\x0ccommand-meta\x03\
\0\0\x02\x03\x02\x01\x06\x04\0\x0ecommand-result\x03\0\x02\x01p\x01\x01@\0\0\x04\
\x04\0\x0dlist-commands\x01\x05\x01ps\x01@\x02\x04names\x04argv\x06\0\x03\x04\0\x03\
run\x01\x07\x03\0\x18wacli:cli/registry@2.0.0\x05\x07\x01B\x07\x01ks\x01ps\x01r\x0f\
\x04names\x05short\0\x04long\0\x04helps\x08required\x7f\x0ddefault-value\0\x03en\
v\0\x0avalue-name\0\x0btakes-value\x7f\x08multiple\x7f\x0avalue-type\0\x0fpossib\
le-values\x01\x0econflicts-with\x01\x08requires\x01\x06hidden\x7f\x04\0\x0aarg-s\
chema\x03\0\x02\x01p\x03\x01r\x09\x04names\x07summarys\x05usages\x07aliases\x01\x07\
versions\x06hidden\x7f\x0bdescriptions\x08examples\x01\x04args\x04\x04\0\x0ecomm\
and-schema\x03\0\x05\x03\0\x16wacli:cli/schema@2.0.0\x05\x08\x02\x03\0\x05\x0eco\
mmand-schema\x01B\x09\x02\x03\x02\x01\x09\x04\0\x0ecommand-schema\x03\0\0\x01r\x03\
\x04names\x07versions\x0bdescriptions\x04\0\x08app-meta\x03\0\x02\x01@\0\0\x03\x04\
\0\x0cget-app-meta\x01\x04\x01p\x01\x01@\0\0\x05\x04\0\x0clist-schemas\x01\x06\x03\
\0\x1fwacli:cli/registry-schema@2.0.0\x05\x0a\x01B\x03\x01j\0\0\x01@\0\0\0\x04\0\
\x03run\x01\x01\x04\0\x12wasi:cli/run@0.2.9\x05\x0b\x04\0\x14wacli:cli/core@2.0.\
0\x04\0\x0b\x0a\x01\0\x04core\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
wit-component\x070.244.0\x10wit-bindgen-rust\x060.52.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

